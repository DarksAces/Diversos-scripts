<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Editor Live</title>
  <style>
    /* Tus estilos actuales est치n bien, a침adir solo esto: */
    .external-change {
      background-color: #2d5a2d !important;
      transition: background-color 0.5s ease;
    }
    .change-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(76, 175, 80, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      animation: fadeOut 2s forwards;
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="status" class="saved">Sincronizado</div>
  <textarea id="editor" placeholder="Escribe aqu칤 tu contenido..."></textarea>
  <div id="images-container"></div>
  
  <script>
    const editor = document.getElementById('editor');
    const status = document.getElementById('status');
    let cleanupFunctions = [];

    // Funci칩n para mostrar notificaci칩n de cambio externo
    function showExternalChangeNotification() {
      const notification = document.createElement('div');
      notification.className = 'change-notification';
      notification.textContent = '游닇 Cambio externo detectado';
      document.body.appendChild(notification);
      
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 2000);
    }

    // Configurar listeners con cleanup
    function setupListeners() {
      // Listener para cambios iniciales
      const cleanupFileChange = window.electronAPI.onFileChange((text) => {
        console.log('Contenido inicial cargado');
        editor.value = text;
        updateStatus(true);
      });
      cleanupFunctions.push(cleanupFileChange);

      // Listener para cambios externos (EL M츼S IMPORTANTE)
      const cleanupExternalChange = window.electronAPI.onExternalFileChange((text) => {
        console.log('游댠 Cambio externo detectado en frontend');
        
        // Guardar estado actual
        const cursorPosition = editor.selectionStart;
        const scrollTop = editor.scrollTop;
        const hasFocus = document.activeElement === editor;
        
        // Mostrar notificaci칩n visual
        showExternalChangeNotification();
        
        // Aplicar cambios
        editor.value = text;
        
        // Restaurar estado
        setTimeout(() => {
          if (cursorPosition <= text.length) {
            editor.setSelectionRange(cursorPosition, cursorPosition);
          }
          editor.scrollTop = scrollTop;
          if (hasFocus) editor.focus();
          
          // Efecto visual de actualizaci칩n
          editor.classList.add('external-change');
          setTimeout(() => editor.classList.remove('external-change'), 500);
        }, 10);
        
        updateStatus(true);
      });
      cleanupFunctions.push(cleanupExternalChange);

      // Listener para im치genes
      const cleanupImages = window.electronAPI.onLoadImages((images) => {
        console.log('Cargando im치genes:', images.length);
        const container = document.getElementById('images-container');
        container.innerHTML = '';
        images.forEach(imgPath => {
          const img = document.createElement('img');
          img.src = imgPath;
          img.title = imgPath.split('/').pop();
          container.appendChild(img);
        });
      });
      cleanupFunctions.push(cleanupImages);
    }

    // Funci칩n para actualizar estado
    function updateStatus(isSaved) {
      if (isSaved) {
        status.textContent = 'Sincronizado';
        status.className = 'saved';
      } else {
        status.textContent = 'Guardando...';
        status.className = 'saving';
      }
    }

    // Manejar guardado con Ctrl+S
    editor.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        console.log('Guardando manualmente...');
        window.electronAPI.saveFile(editor.value);
        updateStatus(false);
        setTimeout(() => updateStatus(true), 300);
      }
    });

    // Manejar clicks en im치genes
    document.addEventListener('click', (e) => {
      if (e.target.tagName === 'IMG' && e.target.parentNode.id === 'images-container') {
        const imageName = e.target.title;
        const cursorPos = editor.selectionStart;
        const textBefore = editor.value.substring(0, cursorPos);
        const textAfter = editor.value.substring(cursorPos);
        
        const imageTag = `[imagen: ${imageName}]`;
        editor.value = textBefore + imageTag + textAfter;
        
        // Mover cursor despu칠s de la imagen insertada
        const newCursorPos = cursorPos + imageTag.length;
        editor.setSelectionRange(newCursorPos, newCursorPos);
        editor.focus();
      }
    });

    // Inicializar
    document.addEventListener('DOMContentLoaded', () => {
      setupListeners();
      console.log('Editor Live inicializado y escuchando cambios...');
    });

    // Limpiar listeners cuando se cierre la p치gina
    window.addEventListener('beforeunload', () => {
      cleanupFunctions.forEach(cleanup => cleanup());
    });
  </script>
</body>
</html>